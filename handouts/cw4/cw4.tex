% vim: textwidth=0 nowrap
\newcommand{\doctitle}{Курсова Работа: Част Последна\\До вторник, 13. януари 2026 г. 23:59}

\input{../common/preamble}

\begin{document}

\maketitle
\thispagestyle{fancy}

\section{Обзор на курсовата работа}\label{sec:overview}

Курсовата работа се състои от четири части, които съответстват на четирите основни фази на един компилатор---лексикален анализатор, синтактичен анализатор, семантичен анализатор и генератор на код.
Тук пропускаме фазата за оптимизации, понеже целта ни е да създадем възможно най-простия работещ компилатор.
Всяко задание води до създаването на работеща фаза на компилатора, която да може да взаимодейства с останалите фази.
Ще реализирате вашият компилатор на C++.

Първите три части от курсовата работа изискваха от вас да създадете \emph{лексикален}, \emph{синтактичен} и \emph{семантичен анализатор} за програмния език COOL.
Последната (тази) част от курсовата работа изисква от вас да създадете \emph{генератор на RISC-V код} за COOL.
С приключването на тази част от курсовата работа ще имате завършен компилатор от COOL до RISC-V асембли!

Ако една програма премине успешно първите три фази, значи тя е валидна COOL програма.
Това означава, че за нея може да се генерира (машинен) код.
Все пак няма гаранции, че няма да възникнат грешки по време на изпълнение, или че програмата върши каквато и да е полезна дейност. Генераторът на код е длъжен да добави проверки за евентуални грешки по време на изпълнение.
Като част от заданието, вашият генератор на код трябва да се справя с възможните грешки по време на изпълнение (описани по-късно в този документ).

Заданието е да напишете програма на C++, която да генерира RISC-V код за дадена програма на COOL.
Крайната цел е: програмата която напишете, да приема като вход типизирано АСД на COOL програма и да отпечатва генерирания асембли код на стандартния изход.

Следната документация ще ви бъде от полза по време на работа:

\begin{enumerate}
    \item \href{https://web.stanford.edu/class/cs143/materials/cool-manual.pdf}{Ръководството за COOL (на английски)}, особено раздел 13 -- Operational Semantics.
    \item \href{https://web.stanford.edu/class/cs143/materials/cool-runtime.pdf}{Системата за Изпълнение на COOL (на английски)}.
\end{enumerate}

Разрешено е да работите индивидуално или по двойки. Ако работите по двойки, всеки е длъжен да предаде общата работа поотделно.

\section{Процес на Работа}\label{sec:process}
\subsection{Сваляне и Пускане на Контейнер}

За да започнете работа, изтеглете последната версия на docker контейнера.
Този път има промени по контейнера, така че е важно да обновите контейнера си локално.

\verbatimfont{\ttfamily}
\begin{verbatim}
  docker pull ghcr.io/aristotelis2002/uni-cool:cw4
  <cd to your work dir>
  docker run -it --name cc-cw4 -v "$(pwd):/home/student/my-code" \
    ghcr.io/aristotelis2002/uni-cool
\end{verbatim}

Обърнете внимание на това, че трябва да ползвате етикет на контейнера cw4-arm, вместо cw4, ако сте с ARM процесор (по-нов macbook компютър).
След като вече имате работещ контейнер, достатъчно е да използвате docker start за да го достъпите:

\verbatimfont{\ttfamily}
\begin{verbatim}
  docker start -ai cc-cw4
\end{verbatim}

\subsection{Сваляне и Пускане на Шаблонен Код}

Свалете шаблона за тази част от курсовата работа и го копирайте в папка, в която ще работите.

\begin{verbatim}
  git clone https://github.com/Aristotelis2002/uni-coolc temp
  cp -r temp/cw4template cw4 && chmod -R g+w cw4
  cd cw4 && chmod +x ./tools/*.sh
\end{verbatim}

\noindent Шаблонът съдържа следните неща:

\begin{enumerate}
    \item папка tools, която съдържа инструменти за компилиране и тестване;
    \item папка tests, която съдържа тестовите файлове за оценяването;
    \item папка lib, която съдържа всички нужни библиотеки от предишните части;
    \item папка include, която съдържа header файлове за служебните lexer, parser и семантичен анализатор; и
    \item папка src, в която трябва да напишете вашия код.
\end{enumerate}

Кодът, който трябва да промените за това задание се намира във файла CoolCodegen.cpp в папката src/codegen.

Папката include освен header файловете за служебните lexer и parser също съдържа и header файлове за типизираното АСД, както и за CoolSemantics.h.
Организацията на шаблонния проект следва система на разделяне на .cpp от .h файловете.
Респективно, те живеят в папките src и include, които имат идентична структура от под-папки помежду си.
Не сте длъжни да спазвате тази структура, но в противен случай може да се сблъскате с проблеми при компилацията на проекта, който ще трябва сами да оправите.

След промяна по кода, рекомпилирайте семантичния анализатор чрез скрипта ``tools/build.sh''.
За да започнете, извикайте този скрипт преди да сте направили каквито и да е промени и потвърдете, че той успешно завършва.

\begin{verbatim}
student@b9404ee896a3:~/my-code/cw4$ ./tools/build.sh
-- The CXX compiler identification is GNU 13.3.0
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
[...]
[100%] Built target codegen
\end{verbatim}

Обърнете внимание, че ако сте с ARM процесор, трябва да преместите \_arm.a файловете върху стандартните .a файлове, за да е успешна компилацията.
Може да постигнете това, например чрез:

\begin{verbatim}
for f in $(ls lib/*arm.a) ; do mv $f ${f%_arm.a}.a ; done
\end{verbatim}

\noindent След това отново опитайте да изпълните tools/build.sh, както е описано по-горе.
\par\vspace{10pt}

Шаблонното решение успешно минава 3 от тестовете.
За да проверите това, изпълнете tools/test-codegen.sh.

\begin{verbatim}
student@b9404ee896a3:~/my-code/cw4$ ./tools/test-codegen.sh
[...]
Total 3 out of 100 tests PASSED
\end{verbatim}

Този скрипт е доста приказлив, така че е добавена възможност да изпълнява само някои от тестовете, подвайки префикс на името на теста, който да се изпълни.
Така ./tools/test-codegen.sh 01 ще изпълни 10 теста -- 010, 011, 012, и т.н. до 019.

\section{Задание}

Заданието е да напишете програма на C++, която да генерира следните структури / код на RISC-V асембли за дадена програма на COOL:
\begin{enumerate}
    \item код за методите на класовете;
    \item прототипни обекти, представляващи всеки клас;
    \item диспечески таблици, по една за всеки клас;
    \item инициализиращи методи, по един за всеки клас;
    \item таблица с имената на класовете;
    \item статични константи; и
    \item построяване на типизирано АСД.
\end{enumerate}

Крайната цел е, програмата която напишете, да използва типизирано АСД на входната програма, за да генерира изпълним файл, следващ операционната семантика на езика COOL.
За постигане на тази цел е достатъчно вашият генератор на код да отпечата асембли инструкциите на стандартния изход.
Помощният скрипт в ``tools/run-asm.sh'' улеснява асемблирането на генерираната програма и свързването ѝ с runtime библиотеката, реализираща системните аспекти от езика COOL за RISC-V.
Същият този скрипт зарежда полученият изпълним файл в симулатора Spike и предва контрола на него.
Ако извикване на скрипта води до зависване, чрез Ctrl+C може да прекъснете симулацията и да се озовете в CLI интерфейса на Spike.
За повече информация относно RISC-V програмиране и използване на Spike, вижте \href{https://learn.fmi.uni-sofia.bg/pluginfile.php/577641/mod_resource/content/1/cc-tut09.pdf}{документа за упражнение 9} в Мудъл.

Спецификацията на операционната семантика е описана в \href{https://web.stanford.edu/class/cs143/materials/cool-manual.pdf}{Ръководството за COOL (на английски)}, раздел 13 -- Operational Semantics.
Кодът, който трябва да промените за това задание се намира във файла CoolCodegen.cpp в папката src/codegen.
Изискването е този код да генерира всички структури и изпълним код описани по-горе.

Като допълнителна насока, може да реализирате генератор на код на ниво ``израз'' и да го преизползвате при генерирането на методи и инициализатори.
По-общо, реализирането на този генератор на код на ниво ``израз'' е еквивалентно на реализирането на операционната семантика на езикът COOL, както е описана в ръководството за COOL.
Шаблонът съдържа достатъчно код, така че да можете да започнете итеративна работа.

Един начин да подходите към решението е да изпълнявате тестовете подред.
Ако някой тест не минава да промените решението си и да опитате пак, докато тестващия скрипт не даде резултат PASSED.
За повече информация, вижте предния раздел: Раздел \ref{sec:process}.

Преди да започнете работа, прочетете внимателно раздел 13 от ръководството.
Също така, ще е нужно да прочетете и документа за системата на изпълнение на COOL, посочен в Раздел \ref{sec:overview}.
Може да игнорирате коментарите относно CoolAid, понеже те не се отнасят за нашия курс.

Вашият генератор на код трябва да е стабилен---трябва да приема всяка валидна програма на COOL.
Трябва да се погрижите в случай на грешка, програмата да завършва по безопасен начин.
Не е приемливо да се стига до изключения в симулатора, например:

\begin{verbatim}
core   0: exception trap_instruction_access_fault, epc 0x00000000
core   0:           tval 0x00000000
\end{verbatim}

Има няколко различни възможности за грешка по време на изпълнение на COOL програма, които са документирани в различните документи, както и в слайдовете от лекциите.

\textbf{За да е възможно автоматичното оценяване, изходът от генерирания от вас код трябва точно да съвпада с предоставените тестове.}
Вижте раздел \ref{sec:process} за повече информация как да компилирате и тествате решението си.

\section{Общи Насоки}

\subsection{Типизирано АСД}

В папката include/semantics/typed-ast има header файлове, които ще ви се наложи да използвате, за да обхождате структурата на изходната COOL програма.
Повечето класове са под-типове на Expr, който също е дефиниран в typed-ast.
Един начин да подходите към построяването на вашия генератор на код е да реализирате клас ExpressionGenerator.
Този клас ще предоставя метод emit\_expr, като при зададен указател към Expr, ще проверява динамичният тип на променливата и ще изпълнява съответното действие.
Например, кодът ви би могъл да започва така:

\begin{verbatim}
void ExpressionGenerator::emit_expr(ostream &out, const Expr *expr) {
    if (auto assignment = dynamic_cast<const Assignment *>(expr)) {
        return emit_assignment(out, assignment);
    }

    if (auto static_dispatch = dynamic_cast<const StaticDispatch *>(expr)) {
        return emit_static_dispatch(out, static_dispatch);
    }
    ...
}
\end{verbatim}

\noindent След това ще трябва да реализирате специфичен метод за всеки възможен израз, според операционната семантика на COOL.

Не е нужно да реализирате целият ExpressionGenerator преди да се опитате да го използвате.
Достатъчно е да имате само няколко реализирани израза, преди да преминете към реализирането на MethodImplementations генератор.
Този клас ще има нужда от достъп до class\_table\_ променливата на CoolCodegen.
Чрез class\_table\_->get\_method\_body може да достъпите тялото на метода и да го предадете на ExpressionGenerator, за да генерира код за него.
Съществуването на MethodImplementations е полезно, понеже освен тяло за метода, трябва да се генерира и етикет, инструкции за последователността на обръщението (извикването) към метода и т.н.

\subsection{Допълнителен Код}

За ваше улеснение сме предоставили допълнителен код в include/codegen и src/codegen.
Това са класовете за позиции в паметта -- Location и Register -- както и помощна библиотека за отпечатване на някои инструкции: CodeEmitter и Mnemonic.
Помощните функции варират от emit\_indent, която просто отпечатва отместване, до emit\_move\_data\_between\_locations, която може да генерира различни последователности.
Разгледайте CodeEmitter.h за подробности.

Register.h предоставя структури, които представляват различните видове регистри в RISC-V.
Самият код е достатъчно прост и описателен, както може да се види от следния откъс:

\begin{verbatim}
using Register =
    std::variant<ZeroRegister, ReturnAddress, StackPointer, GlobalPointer,
                 ThreadPointer, TempRegister, FramePointer, SavedRegister,
                 ArgumentRegister, VirtualRegister>;
\end{verbatim}

\noindent Location.h дефинира няколко вида локации: регистър, място в паметта, атрибут на текущия клас, или ``никаква локация''.
За примерна употреба, разгледайте CodeEmitter.cpp.

Сами преценете дали да използвате допълнителния код или не.
Употребата му не е задължителна част от решаването на тази част от курсовата работа.
Обърнете внимание, че сам по себе си допълнителният код не е достатъчен за реализация на генератор на код.
Той реализира само неща от най-фина подробност, които трябва да комбинирате в по-сложни функции, за да получите полезен генератор.

\subsection{Генериране на Код}

Понякога е доста трудно да автоматизираме процес, без да сме го упражнили ръчно.
Затова е добра идея, преди да реализирате вашия генератор за код, да напишете няколко откъса от асембли на ръка.
\href{https://learn.fmi.uni-sofia.bg/pluginfile.php/577641/mod_resource/content/1/cc-tut09.pdf}{Документът за упражнение 9} дава първоначални насоки относно как да направите това.
Първоначалната реализация на шаблонния код отпечатва съдържанието на 001.hello\_world.example.s, който е ръчно решение на първия тест от множеството от тестове за тази част от курсовата работа.
Този асембли файл е предоставен като част от шаблонния код, с надеждата, че може да ви даде идеи за някои подходи в програмирането на RISC-V асембли.
И все пак, не го взимайте за безупречен пример -- не изисква много усилия примерът да бъде подобрен.

\section{Предаване на Решение}

За да предадете решение, изпълнете ``tools/grade-codegen.sh'' в контейнера.
Този скрипт ще отпечата код за предаване, например ``3:eccbc87e4b5ce2fe28308fd9f2a7baf3''.
Копирайте този код в специалния \href{https://learn.fmi.uni-sofia.bg/mod/quiz/view.php?id=363644}{формуляр за предаване в Мудъл}.
Освен това, трябва да качите и променения от вас код в специалната \href{https://learn.fmi.uni-sofia.bg/mod/publication/view.php?id=363646}{папка за предаване в Мудъл}.
Ако сте променили C++ проекта, така че да включва и други файлове, качете и тях в папката.

По изключение, предаването на решение за тази част от курсовата работа може да ви донесе допълнителен бонус.
Ако решението ви успешно минава поне 20 от стоте теста, това би ви гарантирало взимане на курса с минимална оценка.
Така че ако имате съмнения дали ще успеете да съберете достатъчно точки за да минете курса, си струва да се опитате да решите тази част от курсовата работа за поне 20\%.
В случай, че имате достатъчно точки за да вземете курса, решаването на тази част от курсовата работа няма да се отрази на оценката ви по извънреден начин.
Тя все още носи 6\% от общата оценка.

\end{document}
