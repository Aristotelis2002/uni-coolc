% vim: textwidth=0 nowrap
\newcommand{\doctitle}{Упражнение 09: Програмиране на RISC-V асембли}
\input{../common/preamble}

\usepackage[newfloat]{minted} % defines the listing float
\usepackage{float}

\renewcommand{\listingname}{Код}
\renewcommand{\listlistingname}{Списък с кодове}

\begin{document}

\maketitle
\thispagestyle{fancy}


\tableofcontents

\section{Какво е RISC-V?}

RISC-V е последно поколение Reduced Instruction Set Computer (RISC) архитектура.
Разработен е през 2010 и представен през 2014 от университета в Бъркли \cite{riscv-intro}.
RISC-V е най-успешната свободна и отворена архитектура на набор от инструкции (instruction set architecture).

Създаването ѝ е вдъхновено от недостатъци и тромавост на дизайна на ARM v7, както и от ограничения около интелектуалната собсвеност свързани с ARM.
Десет години след създаването си, екосистемата продължава да се развива активно \cite{riscv-growth}.
През 2024 се прогнозира, че до 2030 почти четвърт от всички продавани процесори ще ползват RISC-V \cite{riscv-market}.

Като изключим факта, че повечето лаптопи и настолни компютри все още ползват x86, RISC е водещата парадигма в компютърните архитектури.
Основната конкуренция на x86 -- ARM архитектурата (семейство от архитектури) -- е също RISC.
ARM доминира мобилните устройства, и започва да печели пазарен дял и при лаптопите (Apple M1, M2, т.н.).
При сървърите, AWS Graviton доказва същото, което Apple чиповете доказват при лаптопите: че ARM ядрата могат да са хем по-бързи, хем по-енерго-ефикасни от x86 ядрата.

Учейки за RISC-V ще добиете знания и умения, които са директно приложими в програмирането на ARM assembly.
Също така, въпреки че x86 е CISC, все пак много от принципите са същите.
Така че RISC-V е най-добрият избор за компютърна архитектура в образованието в момента.

\section{Първата Ви (RISC-V) Асембли Програма}

За това упражнение ще ви е нужен лаптоп и копие на docker контейнера на курса:

\begin{minted}{bash}
  docker pull ghcr.io/aristotelis2002/uni-cool
  # <cd to your work dir>
  docker run -it --name cc-tutorial -v "$(pwd):/home/student/my-code" \
    ghcr.io/aristotelis2002/uni-cool
\end{minted}

\noindent Започнете с това, да свалите шаблонен проект от хранилището с код за курса:

\begin{minted}{bash}
  git clone https://github.com/Aristotelis2002/uni-coolc temp
  cp -r temp/tut09template tut09 && chmod -R g+w tut09
  cd tut09 && chmod +x ./tools/*.sh
\end{minted}

Ще пишете вашата програма във файла ``program.s''.
Да започнем с нещо много просто: сборът на едно плюс едно.
Добавете следния код в ``program.s'':

\begin{listing}[ht]
\caption{Едно плюс едно на RISC-V асембли}
\label{lst:code1}
\begin{minted}{nasm}
  li t0, 1
  li t1, 1
  add t0, t0, t1
\end{minted}
\end{listing}

\noindent Да го асемблираме и пуснем чрез ``tools/build-and-run.sh'':

\begin{minted}{bash}
  tools/build-and-run.sh
\end{minted}

\noindent Това, което получаваме, е ``зависващо изпълнение''. Хмм... Ctrl+C?

\begin{minted}{text}
  student@41321042a23f:~/my-code/tut09$ ./tools/build-and-run.sh
  warning: tohost and fromhost symbols not in ELF; can't communicate with target
  ^C(spike)
\end{minted}

\noindent Ctrl+C изглежда ни постави в debug режим на симулатора.
Да видим какви команди са достъпни. Напишете ``h'' и натиснете ``Enter''.

\begin{minted}{text}
  (spike) h
  Interactive commands:
  
  [...] many commands
  
  run [count]                     # Resume noisy execution (until CTRL+C, or [count] insns)
  r [count]                         Alias for run
  rs [count]                      # Resume silent execution (until CTRL+C, or [count] insns)
  quit                            # End the simulation
  q                                 Alias for quit
  help                            # This screen!
  h                                 Alias for help
  Note: Hitting enter is the same as: run 1
\end{minted}

Натискането на ``Enter'' всъщност е същото като ``run'', не ``run 1'': продължава изпълнението на програмата, като отпечатва всяка инструкция.
Всъщност, първоначално, симулатора започва в ``тих'' режим, тоест еквивалента на ``rs'' от debug режима.
Излезте от симулатора с ``q'' и ``Enter''.

За да спрете Spike преди първата инструкция, добавете аргумента ``-d'' към командата (Spike се извиква от ``tools/build-and-run.sh'').
След като го направите, натискането на ``Enter'' вече е еквивалентно на ``run 1''.

\begin{minted}{bash}
  spike -d --isa=RV32IMZICSR build/a.out
\end{minted}

\noindent Сега поискайте да се изпълнят десет инструкции от програмта чрез ``run 10'':

\begin{minted}{text}
  (spike) run 10
  core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
  core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
  core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
  core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
  core   0: 0x00001010 (0x00028067) jr      t0
  core   0: 0x80000000 (0x00100293) li      t0, 1
  core   0: 0x80000004 (0x00100313) li      t1, 1
  core   0: 0x80000008 (0x006282b3) add     t0, t0, t1
  core   0: 0x8000000c (0x00000000) c.unimp
  core   0: exception trap_illegal_instruction, epc 0x8000000c
  core   0:           tval 0x00000000
  core   0: exception trap_instruction_access_fault, epc 0x00000000
  core   0:           tval 0x00000000
\end{minted}

\noindent Интересно нещо, което забелязваме в средата на отпечатания текст са трите инструкции от нашата програма. Сравнете Код \ref{lst:code2} с Код \ref{lst:code1}.

\begin{listing}[ht]
\caption{Част от изхода на Spike след подаване на ``run 10''}
\label{lst:code2}
\begin{minted}{text}
  core   0: 0x80000000 (0x00100293) li      t0, 1
  core   0: 0x80000004 (0x00100313) li      t1, 1
  core   0: 0x80000008 (0x006282b3) add     t0, t0, t1
\end{minted}
\end{listing}

Също така, сега започваме да виждаме и защо симулатора първоначално изглеждаше, че е попаднал в безкраен цикъл.
След изпълнение на инструкциите от нашата програма е достигнато изключение.
От там нататък, симулатора влиза в безкраен цикъл от изключения, както може да се види с последващи ``run <число>'' команди.

За момента няма да мислим този проблем, ами ще проверим дали всъщност симулаторът прави това, което искаме да постигнем чрез нашата програма.
А именно---дали събира едно плюс едно.
За целта, прекъснете текущата симулация с ``q+Enter''.
След това, започнете нова симулация в debug режим и изпълнявайте ``run 1'' докато не се изпълни последната инструкция от програмата, която зададохме:

\begin{minted}{text}
  student@41321042a23f:~/my-code/tut09$ ./tools/build-and-run.sh
  warning: tohost and fromhost symbols not in ELF; can't communicate with target
  (spike) r 1
  core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
  (spike) r 1
  core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
  (spike) r 1
  core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
  (spike) r 1
  core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
  (spike) r 1
  core   0: 0x00001010 (0x00028067) jr      t0
  (spike) r 1
  core   0: 0x80000000 (0x00100293) li      t0, 1
  (spike) r 1
  core   0: 0x80000004 (0x00100313) li      t1, 1
  (spike) r 1
  core   0: 0x80000008 (0x006282b3) add     t0, t0, t1
  (spike)
\end{minted}

\noindent Да проверим съдържанието на регистрите на процесора в този момент. Използвайте ``reg 0'' (0 е номера на виртуалния процесор; в случая -- само един):

\begin{minted}{text}
  (spike) reg 0
  zero: 0x00000000  ra: 0x00000000  sp: 0x00000000  gp: 0x00000000
    tp: 0x00000000  t0: 0x00000002  t1: 0x00000001  t2: 0x00000000
    s0: 0x00000000  s1: 0x00000000  a0: 0x00000000  a1: 0x00001020
    a2: 0x00000000  a3: 0x00000000  a4: 0x00000000  a5: 0x00000000
    a6: 0x00000000  a7: 0x00000000  s2: 0x00000000  s3: 0x00000000
    s4: 0x00000000  s5: 0x00000000  s6: 0x00000000  s7: 0x00000000
    s8: 0x00000000  s9: 0x00000000 s10: 0x00000000 s11: 0x00000000
    t3: 0x00000000  t4: 0x00000000  t5: 0x00000000  t6: 0x00000000
\end{minted}

\noindent Съдържат ли те, това, което очаквате?

\section{Грациозно Напускане}

Нека адресираме проблемът от по-рано относно безкрайния цикъл.
Работата е там, че това което симулираме е свят, в който програмата която сме написали, е единственият код, който се изпълнява на някаква RISC-V машина.
Не можем просто да ``върнем'' стойност или управлението към друга система, защото такава няма.

Една идея е да направим това, което би направила единствената програма на един компютър ако приключи -- да изключим компютъра.
За целта, понякога има ``halt'' инструкция, например ``hlt'' в x86.

RISC процесорите и в това отношение се опитват да са по-прости: вместо това използват "изчакай за прекъсване" (wait for interrupt).
Нека добавим ``wfi'' инструкцията към края на ``program.s'' и да компилираме и изпълним отново.

\begin{listing}[ht]
\caption{Същата програма, като Код \ref{lst:code1}, но с ``изчакай за прекъсване'' накрая.}
\label{lst:code3}
\begin{minted}{nasm}
  li t0, 1
  li t1, 1
  add t0, t0, t1
  wfi
\end{minted}
\end{listing}

Ако сега компилираме и пуснем програмата, поведението на Spike при ``run 10'' вече изглежда по-различно.

\begin{minted}{text}
student@4c0e0307783e:~/my-code/tut09$ ./tools/build.sh
student@4c0e0307783e:~/my-code/tut09$ spike -d --isa=RV32IMZICSR build/a.out
warning: tohost and fromhost symbols not in ELF; can't communicate with target
(spike) run 10
core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
core   0: 0x00001010 (0x00028067) jr      t0
core   0: 0x80000000 (0x00100293) li      t0, 1
core   0: 0x80000004 (0x00100313) li      t1, 1
core   0: 0x80000008 (0x006282b3) add     t0, t0, t1
core   0: 0x8000000c (0x10500073) wfi
(spike)
\end{minted}

Симулаторът автоматично влиза в debug режим, след като е изпълнена команда wfi.
Последващи run команди не водят до нищо и ``изпълнението'' трябва отново да се прекъсне с Ctrl+C, за достъп до debug режима.
За жалост, Spike не предоставя начин за пращане на ``прекъсване'' (interrupt) към изпълняваната програма (доколкото ми е известно?), така че освен да проверим различни аспекти от състоянието на симулираната машина, няма много полза от този режим на приключване.

Така че нека подходим различно.
Всъщност има начин да прекъснем симулацията от изпълняваната програма и това е използвайки ``tohost'' интерфейса на Spike.
За жалост, той не е добре документиран, но за щастие прочетохме кода и може да кажем че работи по следния начин.

\begin{enumerate}
    \item В .data сегмента на програмата трябва да дефинираме четири етикета: ``tohost'', ``fromhost'', ``tohost\_data'' и ``fromhost\_data'';
    \item да запишем стойността едно в паметта, където сочи ``tohost''; и
    \item да направим така, че изпълнението да ``изчака'' симулацията да приключи.
\end{enumerate}

Точка 3 е важна, защото реализацията на Spike използва многонишковост, и проверява стойностите на ``tohost'' веднъж на всеки няколко хиляди инструкции.
Ако изпълняваната програма не дочака симулацията да приключи, ще достигнем същия проблем като в Код \ref{lst:code1}.
За щастие, вече знаем как да направим това -- чрез инструкцията wfi. Така, нашата програма добива вида в Код \ref{lst:code4}.

\begin{listing}[ht]
\caption{Същата програма, като Код \ref{lst:code1}, но приключваща симулацията след изпълнение.}
\label{lst:code4}
\begin{minted}{nasm}
# Program logic.
    li t0, 1
    li t1, 1
    add t0, t0, t1
# Tell Spike to stop the simulation.
    la t0, tohost
    li t1, 1
    sw t1, 0(t0)
# Wait for interrupt.
    wfi
# Data part of 'tohost' interface.
.data
tohost:
    .dword 0
fromhost:
    .dword 0
tohost_data:
    .dword 0, 0, 0, 0, 0, 0, 0, 0
fromhost_data:
    .dword 0, 0, 0, 0, 0, 0, 0, 0
\end{minted}
\end{listing}

Компилирайки и пускайки тази програма, виждаме, че тя приключва симулацията, след достатъчно голям аргумент на run (Код \ref{lst:code5}).

\begin{listing}[ht]
\caption{Изход от изпълнението на Код \ref{lst:code4} и подаване на run 5001.}
\label{lst:code5}
\begin{minted}{text}
student@4c0e0307783e:~/my-code/tut09$ ./tools/build.sh
student@4c0e0307783e:~/my-code/tut09$ spike -d --isa=RV32IMZICSR build/a.out
(spike) r 5001
core   0: 0x00001000 (0x00000297) auipc   t0, 0x0
core   0: 0x00001004 (0x02028593) addi    a1, t0, 32
core   0: 0x00001008 (0xf1402573) csrr    a0, mhartid
core   0: 0x0000100c (0x0182a283) lw      t0, 24(t0)
core   0: 0x00001010 (0x00028067) jr      t0
core   0: 0x80000000 (0x00100293) li      t0, 1
core   0: 0x80000004 (0x00100313) li      t1, 1
core   0: 0x80000008 (0x006282b3) add     t0, t0, t1
core   0: 0x8000000c (0x00800297) auipc   t0, 0x800
core   0: 0x80000010 (0xff428293) addi    t0, t0, -12
core   0: 0x80000014 (0x00100313) li      t1, 1
core   0: 0x80000018 (0x0062a023) sw      t1, 0(t0)
core   0: 0x8000001c (0x10500073) wfi
student@4c0e0307783e:~/my-code/tut09$
\end{minted}
\end{listing}

\section{По-интересна Програма}

След като имаме този работещ шаблон, е време да разгледаме по-интересни програми.
Нека видим как може да правим избор в RISC-V асембли.

\par\vspace{10pt}
Задача 1. Заредете определено число в t0 с една инструкция.
Напишете програма, която проверява дали числото е 11. Ако е, t1 става равно на 42; в противен случай, t1 става равно на 1337.
\par\vspace{10pt}

\noindent Опитайте да решите задачата сами, преди да продължите с четенето.
\par\vspace{10pt}

Има два различни подхода към тази задача.
Единият е, да използваме етикети и условно изпълнение.
Това е стандартният подход и него ще разгледаме първо.

Етикетите (labels) са начин да се именува част от паметта, била тя в частта за данни или в частта за програмен код.
Може би са ви познати от езици, които поддържат goto командата.
Всъщност вече ползвахме етикети в това упражнение: това са ``tohost'', ``fromhost'' и т.н.

Освен за да именуваме конкретни данни в паметта, етикетите ни помагат да пренасочваме контрола по време на изпълнение.
С други думи, ако именуваме част от кода на програмата чрез етикет, това ни позволява да укажем изпълнението да продължи от там.
За целта се ползва някоя от ``разклоняващите'' (branching) инструкции.
Това ``разклоняване'' може да бъде условно или безусловно.
Най-простата инструкция за втория случай е jump.

Когато разклоняването е условно, трябва инстукцията да определя и какво е условието.
За да решим задачата по-горе ще използваме ``branch-if-equal`` или beq инструкцията.
Код \ref{lst:code4} предполага, че сме запазили шаблонните части от Код \ref{lst:code6}, но сме променили само ``Program logic'' частта.

\begin{listing}
\caption{Решение на Задача 1.}
\label{lst:code6}
\begin{minted}{nasm}
# Pretend input 
    li t0, 33
# Program logic
if:
    li t2, 11
    beq t0, t2, then
else:
    li t1, 1337
    j fi
then:
    li t1, 42
fi:
# Tell Spike to stop the simulation.
    la t0, tohost
    # ...
\end{minted}
\end{listing}

Това, което може да забележим е, че else и then етикетите са в обратен ред на това, с което сме свикнали от езиците от високо ниво.
Също така сме добавили ненужния етикет if, за яснота.
Без него програмата ще работи по напълно същия начин.
Важно е да обърнете внимание на етикета fi и безусловния скок от края на end блока към него.
Ясно е защо е нужен -- в противен случай биха се изпълнили и двете разклонения на условието, което рядко е това, което искаме.
Но му обръщаме внимание, понеже също така е често срещана грешка да се пропусне от програмиста на асембли.

ChatGPT би казал, че тази подредба на етикетите е грешна.
За жалост, като по-добра подредба предлага същия код, без съществени промени.
И все пак, по-ясна подредба може би била тази представена в Код \ref{lst:code7}.

\begin{listing}
\caption{Алтернативно решение на Задача 1. Подпрограмите за then и else са в стандартния ред, в който са в езиците от високо ниво.}
\label{lst:code7}
\begin{minted}{nasm}
# Pretend input 
    li t0, 33
# Program logic
if:
    li t2, 11
    beq t0, t2, then
    j else
then:
    li t1, 42
    j fi
else:
    li t1, 1337
fi:
# Tell Spike to stop the simulation.
    la t0, tohost
    # ...
\end{minted}
\end{listing}

В тази подредба подпрограмите за then и else са в стандартния ред, в който са в езиците от високо ниво.
Възможна е и (поне) още една алтернатива, в която подредбата пак е ``нормална'', но условието е обърнато.
Тази алтернатива е представена в Код \ref{lst:code8}.

\begin{listing}
\caption{Алтернативно решение на Задача 1. Подпрограмите за then и else са в стандартния ред, но условието е обърнато.}
\label{lst:code8}
\begin{minted}{nasm}
# Program logic
    li t0, 33
if:
    li t2, 11
    bne t0, t2, else
then:
    li t1, 42
    j fi
else:
    li t1, 1337
fi:
# Tell Spike to stop the simulation.
    la t0, tohost
    # ...
\end{minted}
\end{listing}

Това позволява да си спестим една инструкция за безусловен скок директно след проверката и да получим по-кратка програма.
От гледна точка на производителност по-кратката програма почти винаги е по-производителна.
Така че, ако целим висока производителност, всяка пропусната инструкция е предимство.
За сметка на това обръщането на условието може да доведе до объркване по-късно за това каква точно е логиката на програмата.
Обърнете внимание на мнемониката за ``branch-not-equal'' -- bne.

Последно нещо, което ще разгледаме преди да приключим със Задача 1. е възможността въобще да не използваме разклоняващи инструкции.
Един начин да направим това е чрез пълна \emph{аритметризация} на условния оператор.
Логиката е следната, ако извадим от t0 числото 11, ще получим нула само ако t0 изпълнява условието от Задача 1. (t0 = 11).
Чрез умножение, може да премахнем алтернативното разклонение (t1 = 1337).
Въпросът, който остава да решим е ``как да получим 1, за да умножим с него истинното разклонение?''.

Отговорът е, че можем да използваме RISC-V инструкцията "set-less-than-immediate", която присвоява стойността 1 на целевия регистър, ако левият аргумент е по-малък от десния.
В противен случай, присвоява 0 на целевия регистър.
Решение на Задача 1. е представено в Код \ref{lst:code9}, което ползва тази инструкция.

\begin{listing}
\caption{Алтернативно решение на Задача 1. Условният оператор е \emph{аритметизиран}.}
\label{lst:code9}
\begin{minted}{nasm}
# Pretend input
    li t0, 15
# Program logic
    slti t3, t0, 11 # t3 is 1 if t0 is 10 or less
    li t2, 1337
    mul t1, t2, t3  # t1 is 1337 if t0 is 10 or less; otherwise t1 is 0
    li t4, 1
    sub t4, t4, t3  # t4 is 1 if t0 is 11 or more
    slti t3, t0, 12 # t3 is 1 if t0 is 11 or less
    and t4, t3, t4  # t4 is 1 if t0 is 11
    li t2, 42
    mul t2, t2, t4  # t2 is 42 if t0 is 11; otherwise t2 is 0
    add t1, t1, t2
    li t4, 1
    sub t3, t4, t3  # t3 is 1 if t0 is 12 or more
    li t2, 1337
    mul t2, t2, t3  # t2 is 1337 if t0 is 12 or more; otherwise t2 is 0
    add t1, t1, t2
\end{minted}
\end{listing}

Важно е да знаем, че освен стандартните инструкции, архитектурите на набор от инструкции съдържат и \emph{псевдоинструкции}.
В първоначалният доклад представящ RISC-V \cite{riscv-intro} са представени четири реални инструкции от фамилията на slti: slt, slti, sltu и sltiu.
Чрез тях, могат да се дефинират псевдоинструкции, които са по-лесни за четене и разбиране от хора.
Например, seqz r1, r2 присвоява на r1 резултата от сравнението на r2 с 0.
Тази псевдоинструкция -- seqz r1, r2 -- е еквивалента на реалната инструкция sltiu r1, r2, 1.

Така може да използваме първоначалната ни идея да извадим от t0 числото 11 и да сравним резултата с 0.
Решение на Задача 1., което използва тази идея и псевдоинструкцията seqz, е представено в Код \ref{lst:code10}.
За ръководство на всички възможни RISC-V инструкции, включително и псевдоинструкциите, използвайте \cite{riscv-asm-manual}, оригиналното хранилище за което се намира на \href{https://github.com/riscv-non-isa/riscv-asm-manual}{този линк}.

\begin{listing}
\caption{Алтернативно решение на Задача 1. Условният оператор е \emph{аритметизиран}. Използвана е псевдоинструкцията seqz.}
\label{lst:code10}
\begin{minted}{nasm}
# Program logic
    addi t0, t0, -11
    seqz t3, t0     # t3 is 1 if t0 was 11
    li t2, 42
    mul t1, t2, t3  # t1 is 42 if t0 was 11
    li t4, 1
    sub t4, t4, t3  # t4 is 1 if t0 was not 11
    li t2, 1337
    mul t2, t2, t4  # t2 is 1337 if t0 was not 11
    add t1, t1, t2
\end{minted}
\end{listing}

Аритметризацията е подход, който избягва условното управление на контрола на програмата.
В някои случаи, това може да доведе до подобрение в производителността, заради ефекти от конвейрното изпълнение на инструкциите в процесора.
За сметка на това, броят на инструкциите в Код \ref{lst:code10} е с две повече от броя на инструкциите в Код \ref{lst:code8}.
Също така, новият код е по-малко четим.
Така че за Задача 2. ще се върнем на инструкциите за условно управление на изпълнението.

\par\vspace{10pt}
Задача 2. Заредете определено положително число в t0 с една инструкция.
Напишете програма, която събира числата от 1 до t0 и записва резултата в t1.
Опитайте да решите задачата сами, преди да продължите с четенето.
\par\vspace{10pt}

Всъщност, няма как да решим задачата чрез аритметризация, без да ``развием'' цикъла, което е тема за по-напреднали в компилацията.
Така че трябва да ползваме инструкцията beq.
Код \ref{lst:code11} решава Задача 2.

\begin{listing}
\caption{Решение на Задача 2.}
\label{lst:code11}
\begin{minted}{nasm}
# Pretend input
    li t0, 10
# Program logic
    li t1, 0
loop:
    beqz t0, end
    add t1, t1, t0
    addi t0, t0, -1
    j loop
end:
\end{minted}
\end{listing}

\section{Четене и Писане на Памет}

Сега ще преминем към друг вид инструкции: такива за четене от и писане в памет.
В лекциите срещнахме такива инструкции основно около боравенето със стека в паметта.
По-рано в това упражнение видяхме как писането в специална част от паметта позволява на нашата програма да взаимодейства със симулатора.

Ако се опитаме да измислим пример за програма четяща и пишеща в паметта, бързо виждаме нуждата от някаква форма на програмно структуриране на паметта.
Какво имам предвид: за да четем и пишем в паметта, трябва да имаме някакъв адрес.
Какъв може да е един примерен адрес?
Може да опитаме да пишем или четем в адрес равен на произволно число, например 0 или 1337.
Но това не работи толкова лесно.
Код \ref{lst:code12} демонстрира това.

\begin{listing}
\caption{Когато симулаторът достигне инструкция за четене или писане в забранен адрес, той хвърля изключение.}
\label{lst:code12}
\begin{minted}{text}
(spike)
core   0: 0x80000000 (0x00002283) lw      t0, 0(zero)
core   0: exception trap_load_access_fault, epc 0x80000000
core   0:           tval 0x00000000
\end{minted}
\end{listing}

Тук, може би е подходящ момент да направим леко отклонение.
И по-рано видяхме ситуации, в които симулаторът задейства изключение.
Механизмът за регистрация на функция, която да адресира ситуацията е следният.

Използват се набор от неспоменати досега регистри и инструкции, част от \emph{привилегированата архитектура}.
Това е част от архитектурата на набора от инструкции, която подпомага реализацията на операционна система за RISC-V-базиран компютър.
Без да задълбаваме особено много, просто ще разгледаме един пример, използващ регистрите mtvec, mepc, както и инструкциите csrr, csrw и mret.
Примерът е реализиран в Код \ref{lst:code13}.

\begin{listing}
\caption{Пример за регистрация на функция, обработваща изключения.}
\label{lst:code13}
\begin{minted}{nasm}
# Register trap handler
    la   t0, trap_handler
    csrw mtvec, t0

# Program source
    lw t0, 0(zero)
    li t0, 17
    sw t0, 0(zero)
# Tell Spike to stop the simulation.
    la t0, tohost
    li t1, 1
    sw t1, 0(t0)
# Wait for interrupt.
    wfi

# Trap handler
trap_handler:
    csrr t0, mepc
    addi t0, t0, 4
    csrw mepc, t0
    mret
# Data part of 'tohost' interface.
#    [...]
\end{minted}
\end{listing}

Обяснението на функцията обработваща изключения, представена като ``trap\_handler'' в Код \ref{lst:code13} е следното.
Първата инструкция зарежда адреса в паметта, на инструкцията породила изключението.
Този адрес се намира в регистъра mepc и инструкцията csrr (CSR read) позволява неговото прочитане.
CSR идва от ``control and status register''.
Втората инструкция от функцията обработваща изключения увеличава стойността на t0 с 4.
Последната работна инструкция запазва стойността на t0 обратно в mepc, чрез инструкцията csrw (CSR write).
Резултатът от тази функция е, че инструкцията породила изключението се прескача, без да има ефект върху състоянието на машината.
Последната инструкция -- mret -- е специална инструкция за връщане от изпълнението на функция обработваща изключения.

Освен самата функция ``trap\_handler'', новото в Код \ref{lst:code13} е и нейната регистрация.
Това се случва чрез зареждането на адреса ѝ в t0, след което чрез записването на тази стойност в mtvec чрез csrw.
Формално, mtvec е дефиниран като ``Machine trap-handler base address.'' в \cite{riscv-priviledged}, което е и предназначението за което го ползваме.

Но да се върнем към четенето и писането от и в паметта.
Видяхме, че не може да ползваме произволни адреси за това, понеже това може да доведе до пораждането на изключение.
Най-лесният смислен начин да четем и пишем в паметта е използвайки именувана чрез етикет част от нея.
Ако имаме такъв етикет, може да заредим \emph{статично заредена константа} от паметта, към която сочи, или да запишем произволна стойност в \emph{статично заделена памет} от програмата.
Код \ref{lst:code14} демонстрира и двете възможности.

\begin{listing}
\caption{Пример за писане в и четене от памет.}
\label{lst:code14}
\begin{minted}{nasm}
# Program source
    lw t0, static_data
    lw t1, static_alloc
    la t1, static_alloc
    sw t0, 0(t1)
# Tell Spike to stop the simulation.
#    [...]
# Wait for interrupt.
    wfi
.data
# Custom program data
static_data:
    .word 30007
static_alloc:
    .word 0
# Data part of 'tohost' interface.
tohost:
#    [...]
\end{minted}
\end{listing}

Забележете, че в Код \ref{lst:code14} директно можем да заредим дума от паметта, чрез инструкцията lw.
За да заредим адреса на самата памет, трябва да ползваме инструкцията la (load address), което също е демонстрирано в кода.
За разлика от това, не можем да запишем стойност в паметта, чрез ``sw t1, static\_alloc'' например.
Налага се първо да заредим адреса на паметта, където искаме да пишем.
След това, използваме sw за да запишем каквото желаем в тази памет.

Като финал за коментара по този пример: нищо не ни спира да запишем данни на адреса, където се намира статично заделената константа.
Затова трябва да внимаваме, когато реализираме компилатор, това да не се случи.
В противен случай, компилацията може да доведе до много странно поведение на компилираната програма, където константите нямат стойностите, които се очаква.

\par\vspace{10pt}
Задача 3. Изпълнете Код \ref{lst:code14}, след като попълните липсващите полета.
Използвайте информацията предоставена по-рано в този документ.
Използвайте командата ``mem 0 <адрес>'' за да инспектирате съдържанието от паметта на симулатора (spike).
\par\vspace{10pt}

Друго място от паметта, което бихме искали да ползваме за четене и писане и \emph{стекът}.
За жалост, архитектурата на набора от инструкции няма представа какво означава ``стек''.
Да, тя ни предоставя специален регистър, чието име е ``указател към стека'', но стойността на този регистър първоначално е нула.
Както видяхме, не можем да четем и пишем в паметта на адрес нула.

Нужно е нашата програма да се погрижи за това регистър sp да има смислена стойност.
Бихме могли да се опитаме да изчислим някакъв адрес според съдържанието на програмата, но най-лесният начин е просто да сложим максималният възможен адрес и да приемем, че стекът ще расте към ниските адреси.
Максималният възможен адрес е адресът на последната адресируема дума в програмата: 0xffff'fffc.
Код \ref{lst:code15} демонстрира това.

\begin{listing}
\caption{Пример за писане в и четене от памет.}
\label{lst:code15}
\begin{minted}{nasm}
# Initial configuration
    li sp, 0xfffffffc
# Program source
    # push 17 on the stack
    li t0, 17
    sw t0, 0(sp)
    addi sp, sp, -4
    # pop 17 from the stack
    addi sp, sp, 4
    lw t1, 0(sp)
\end{minted}
\end{listing}

Последното, което ще разгледаме в този раздел, е нещо необичайно.
Паметта, където се пази програмата не е защитена по подразбиране в RISC-V.
Това означава, че може да пишем директно в нея, по време на изпълнение.
Това, от своя страна, означава, че програмата може да променя собствените си инструкции, като част от изпълнението си!

\par\vspace{10pt}
Задача 5. Разгледайте Код \ref{lst:code16} и проучете изпълнението му в (spike).
Какво е поведението на програмата.
Приключва ли успешно?
Какво се изпълнява като изчисление?
Откъде се взеха магическите числа, които са зададени да се запишат в паметта?
\par\vspace{10pt}

\begin{listing}
\caption{Нестандартен пример за писане в памет.}
\label{lst:code16}
\begin{minted}{nasm}
start:
      li t0, 1
      li t1, 1
      add t0, t0, t1

      la t0, slot1
      li t1, 0x00100293
      sw t1, 0(t0)

      la t0, slot2
      li t1, 0x00100313
      sw t1, 0(t0)

      la t0, slot3
      li t1, 0x006282b3
      sw t1, 0(t0)
  slot1:
      .word 0
  slot2:
      .word 0
  slot3:
      .word 0
# Tell Spike to stop the simulation.
#    [...]
\end{minted}
\end{listing}

\section{Използване на COOL RISC-V Runtime}

1. С празна програма?

2. С нужните символи?

3. С ``валиден'' обект?

4. С минимален код, напускащ грациозно

\begin{minted}{nasm}
  .globl Main_init
  Main_init:
      call Object.abort
  
  .globl Bool_init
  Bool_init:
  .globl Bool_protObj
  Bool_protObj:
  .globl IO_init
  IO_init:
  .globl IO_protObj
  IO_protObj:
  .globl Int_init
  Int_init:
  .globl Int_protObj
  Int_protObj:
  .globl Main.main
  Main.main:
  
  .globl Main_protObj
  Main_protObj:
      .word 0
      .word 2
  
  .globl Object_init
  Object_init:
  .globl Object_protObj
  Object_protObj:
  .globl String_dispTab
  String_dispTab:
  .globl String_init
  String_init:
  .globl String_protObj
  String_protObj:
  .globl _bool_tag
  _bool_tag:
  .globl _int_tag
  _int_tag:
  .globl _string_tag
  _string_tag:
  .globl class_nameTab
  class_nameTab:
\end{minted}

5. Отпечатващ ``Hello, World!''

6. Четящ име и отпечатващ ``Hello, име!''

\section{Обръщане към Функция}

Ръчна реализация на последователността за извикване от лекциите.

\section{Moonshots}

Да се добавят като функции, следващи COOL calling convention

Да добавим тестове

1. Реализирайте "strlen"

2. Обърнете низ без допълнителна Памет

3. Реализирайте "indexOf" за String

4. Реализирайте: за два указателя и дадена дължина, да се копират толкова байта от първия във втория
! указателите може да са в произволен ред в паметта и по-близо от зададената памет;
! след извикване, данните трябва да са вярни във втория указател, дори и да са (частично) унищожени в първия

\bibliographystyle{plain}
\bibliography{references}

\end{document}
