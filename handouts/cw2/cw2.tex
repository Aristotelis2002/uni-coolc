% vim: textwidth=0 nowrap
\documentclass[11pt]{article}
\usepackage{fontspec}
\usepackage{setspace}
\usepackage{endnotes}
\usepackage{enumitem}
\usepackage[bulgarian]{babel}
\setmainfont{Noto Serif}

\setlist{itemsep=0pt, parsep=0pt, topsep=1em, partopsep=0pt}

\makeatletter
\newcommand{\verbatimfont}[1]{\def\verbatim@font{#1}}%
\makeatother

\newfontfamily\CyrMono[
  Ligatures = NoCommon,     % turn off ligatures
  Mapping = none            % IMPORTANT: disable TeX-style replacements
]{Roboto Mono}

\usepackage[top=2cm,bottom=4.5cm,left=2cm,right=2cm]{geometry}
\usepackage{titling}
\usepackage{lastpage}
\usepackage{fancyhdr}
\lhead{Компилатори, Въведение}
\rhead{}
\lfoot{Зимен семестър, 2025/2026}
\cfoot{}
\rfoot{страница \thepage~от \pageref*{LastPage}}

\setlength{\headheight}{2cm}

\usepackage{xcolor}

\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue]{hyperref}

\title{Курсова Работа: Част Втора\\До вторник, 18. ноември 2025 г. 23:59}
\author{}
\date{}

\setlength{\droptitle}{-4em} % move title up

% these two go together
\predate{}
\postdate{}
\preauthor{}
\postauthor{}

\setstretch{1.2}

\pagestyle{fancy}

\begin{document}

\maketitle
\thispagestyle{fancy}

\section{Обзор на курсовата работа}

Курсовата работа се състои от четири части, които съответстват на четирите основни фази на един компилатор---лексикален анализатор, синтактичен анализатор, семантичен анализатор и генератор на код.
Тук пропускаме фазата за оптимизации, понеже целта ни е да създадем възможно най-простия работещ компилатор.
Всяко задание води до създаването на работеща фаза на компилатора, която да може да взаимодейства с останалите фази.
Ще реализирате вашият компилатор на C++.

Първата част от курсовата работа изискваше от вас да създадете \emph{лексикален анализатор} за програмния език COOL.
Втората (тази) част от курсовата работа изисква от вас да създадете \emph{синтактичен анализатор} (също наричан \emph{parser}) за COOL.
Ще използвате софтуерния инструмент ANTLR4, за да генерирате своя синтактичен анализатор.
Заданието е да създадете контекстно-свободна граматика описваща синтаксиса на COOL в подходящия формат.
ANTLR4 ще генерира C++ кода, който ще разпознава синтактичната структура на дадена COOL програма според вашите правила.
За да използвате генерирания код, ще трябва да модифицирате и управляващата програма (наричана също \emph{driver}), така че да отпечатва произведеното абстрактно синтактично дърво на програмата.
Предоставени са редица тестове демонстриращи очакваното поведение на вашия синтактичен анализатор.
Също така са предоставени и инструменти, които улесняват компилацията и изпълнението на кода ви.

Следната документация ще ви бъде от полза по време на работа:

\begin{enumerate}
    \item \href{https://web.stanford.edu/class/cs143/materials/cool-manual.pdf}{Ръководството за COOL (на английски)}, особено раздел 11 -- Cool Syntax, основно на страница 16; както и
    \item The Definitive ANTLR4 Reference от Terence Parr.
\end{enumerate}

Разрешено е да работите индивидуално или по двойки. Ако работите по двойки, всеки е длъжен да предаде общата работа поотделно.

\section{Процес на Работа}\label{sec:process}

За да започнете работа, изтеглете последната версия на докер контейнера.
Ако сте работили по първата част от курсовата работа и искате да преизползвате лексикалния си анализатор, копирайте .g4 файла си за него в работната папка.
Обърнете внимание, че LexerDriver.cpp няма да ви е директно нужен, макар да може да е полезно да преизползвате част от него (например функцията за отпечатване на името на тип на жетон).

\verbatimfont{\ttfamily}
\begin{verbatim}
  docker pull ghcr.io/aristotelis2002/uni-cool:cw2
  <cd to your work dir>
  docker run -it --name cc-cw2 -v "$(pwd):/home/student/my-code" \
    ghcr.io/aristotelis2002/uni-cool
\end{verbatim}

Обърнете внимание на това, че трябва да ползвате етикет на контейнера cw2-arm, вместо cw2, ако сте с ARM процесор (по-нов macbook компютър).

Свалете шаблона за тази част от курсовата работа и го копирайте в папка, в която ще работите.

\begin{verbatim}
  git clone https://github.com/Aristotelis2002/uni-coolc temp
  cp -r temp/cw2template cw2 && rm -rf temp && chmod -R g+w cw2 && cd cw2 && chmod +x ./tools/*.sh
\end{verbatim}

\noindent Шаблонът съдържа следните неща:

\begin{enumerate}
    \item папка src, която съдържа шаблон на граматиката и прост драйвер; папката съдържа също така и списък със жетоните от служебния lexer;
    \item папка tools, която съдържа инструменти за компилиране и тестване; и
    \item папка tests, която съдържа тестовите файлове за оценяването;
    \item папка lib, която съдържа библиотека със служебния lexer; и
    \item папка include, която съдържа header за служебния lexer.
\end{enumerate}

\noindent Кодът, който трябва да промените за това задание се намира във файловете ``CoolParser.g4`` и ``drivers/ParserDriver.cpp'' в папката src.

След промяна по граматиката или драйвера, рекомпилирайте синтактичния анализатор чрез скрипта ``tools/build.sh''.
За да започнете, извикайте този скрипт преди да сте направили каквито и да е промени и потвърдете, че той успешно завършва.

\begin{verbatim}
student@b9404ee896a3:~/my-code/cw2$ ./tools/build.sh
-- The CXX compiler identification is GNU 13.3.0
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
[...]
[100%] Built target parser
\end{verbatim}

Шаблонното решение успешно минава един от тестовете.
За да проверите това, изпълнете ``tools/test-parser.sh''.

\begin{verbatim}
student@b9404ee896a3:~/my-code/cw2$ ./tools/test-parser.sh 001
Test 001.class PASSED
\end{verbatim}

Този скрипт е доста приказлив, така че е добавена възможност да изпълнява само някои от тестовете, подвайки префикс на името на теста, който да се изпълни.
Така ./tools/test-parser.sh 01 ще изпълни 10 теста -- 010, 011, и т.н.

\section{Задание}

(Следва да се напише.)

Задачата ви е, да напишете ANTLR4 правила, които да дефинират лексикална спецификация на програмният език COOL.
Тази спецификация е описана в \href{https://web.stanford.edu/class/cs143/materials/cool-manual.pdf}{Ръководството за COOL (на английски)}, особено раздел 10 -- Lexical Structure, основно на страница 15.
Вашите правила ще трябва да извършват определени действия за да:

\begin{enumerate}
    \item запишат правилната лексема;
    \item запишат правилния тип на жетона; и
    \item запишат грешка, в случай, че такава възникне.
\end{enumerate}

Преди да започнете работа, прочетете внимателно раздел 10 от ръководството.
Трябва да декларирате поне следните типове жетони:

\verbatimfont{\CyrMono}
\begin{verbatim}
  ASSIGN BOOL_CONST CASE CLASS DARROW ELSE ESAC FI IF IN
  INHERITS INT_CONST ISVOID LE LET LOOP NEW NOT OBJECTID OF
  POOL STR_CONST THEN TYPEID WHILE
\end{verbatim}

За всеки тип жетон, вашето решение трябва да изпълнява определени действия, за да реализирате успешно лексикалната спецификация.
Например, ако разпознаете жетон от тип BOOL\_CONST, решението ви трябва да запише стойността на булевата променлива.
(Шаблонът вече прави това.)
Ако срещнете текстов низ, трябва да запишете верните стойности за всеки символ, след обработка на екраниращите последователности.

Вашият лексикален анализатор трябва да е стабилен---трябва да приема всеки възможен вход.
Например, трябва да се справяте с грешки като EOF по средата на текстов низ или коментар.
Друг пример са текстовите константи, които надвишават ограниченията.
Ръководството на COOL съдържа всички грешки, които трябва да вземете предвид.

Трябва да се погрижите също така, в случай на грешка, програмата да завършва по безопасен начин.
Не е приемливо да се стига до crash-ове или segmentation fault.

\textbf{За да е възможно автоматичното оценяване, изходът от вашия лексикален анализатор трябва точно да съвпада с предоставените тестове.}
Вижте раздел \ref{sec:process} за повече информация как да компилирате и тествате решението си.

(Следва да се напише.)

\section{Общи Насоки}

ANTLR4 е модерен инструмент за генерирането на лексикални и синтактични анализатори.
По подразбиране, инструментът генерира комбинирана библиотека, която изпълнява и двете фази едновременно.
Възможно е да се използва, обаче, и за генериране на фазите поотделно.
В предната част от курсовата работа използвахте ANTLR4 за да генерирате само лексикален анализатор.
В тази част ще го използвате, за да генерирате само синтактичен анализатор, като ще го свържете с лексикалния анализатор от предната част.
Ако не сте предали лексикален анализатор за предната част или не е напълно завършен, може да ползвате служебния такъв, предоставен с материалите за курсовата работа.

ANTLR4 компилира вашия файл със синтактична граматика (например, ``Parser.g4'') към C++ код.
При изпълнение може да се избере дали да се генерира listener, или visitor, като ние ще ползваме второто.
Чрез тази библиотека ще можете да дефинирате преминавания (passes) през абстрактното синтактично дърво на програмата.
Пример за такова преминаване е отпечатващ инструмент, който ще ви е нужен за пълно решение на тази част от курсовата работа.
За щастие, няма нужда да гледате или разбирате генерирания код, за да го ползвате.

\subsection{Обща структура на входния файл}

Синтактничната граматика се дефинира в ANTLR4 по следния начин:

\verbatimfont{\CyrMono}
\begin{verbatim}
parser grammar ИмеНаСинтактичнияАнализатор;
options { tokenVocab=ИмеНаЛексикалнияАнализатор; }
Граматика
\end{verbatim}

В един смисъл, заданието е по-лесно от предното, понеже не е нужно да пишете допълнителен C++ код във файла с граматиката.

Частта "граматика" е дефиниция на контекстно-свободна граматика съответстваща на синтактичната структура на езика.
Дефиницията трябва да следва правилата, определени от спецификацията на ANTLR4.
Поради тази причина е силно препоръчително да се сдобиете с копие на ``The Definitive ANTLR4 Reference'' за изпълнението на тази част от курсовата работа.
Все пак, тук ще се опитаме да опишем най-важните аспекти от спецификацията, но е възможно те да не са достатъчни за пълно решение на заданието.

\subsection{Нетерминали}

В ANTLR4 имената на синтактичните правила (нетерминалите) започват с малка буква.
След името следва двоеточие, след което списък от правила, разделени с вертикална черта.
Списъкът от правила завършва с точка-и-запетая.

Всяко правило от списъка представлява регулярен израз, съдържащ нетерминали и терминали в произволна комбинация.
Терминалите са жетоните от лексикалния анализатор.
Лексемите може да се ползват и директно, стига типът на жетона да позволява само една лексема.
Например, ако е дефиниран следния тип жетон в лексикалната спецификация, \texttt{AT: '@'}, в синтактичната спецификация може да се ползва директно \texttt{'@'}.
Ако лексемата не съответства директно на тип жетон, ANTLR4 ще върне грешка ``cannot create implicit token for string literal in non-combined grammar''.

Да разгледаме следния пример:

\begin{verbatim}
arith : NUM '+' NUM
      | NUM '-' NUM;
\end{verbatim}

\noindent Тук нетерминалът е arith и граматиката за него съдържа две правила: едно за сбор и едно за разлика.
Отново, нужно е и трите вида жетон -- NUM, плюс и минус -- да са дефинирани в лексикалната спецификация, определена в началото на файла чрез \texttt{tokenVocab=}.

\subsection{Приоритет и Асоциативност}

(Предстои да бъде дописано.)

Правилата написани по-рано са ``с по-висок приоритет''.
Възможно е това да доведе до объркване, понеже операции с по-висок приоритет всъщност се появяват по-късно в АСД, но това е правилно.
За постигане на еднакъв приоритет за две операции, те трябва да са реализирани чрез общо правило (на един ред от граматиката).

Операциите са ляво-асоциативни по подразбиране.
Възможно е да се специфицират като дясно-асоциативни, чрез добавяне на <assoc=right> след двоеточието или правата черта \footnote{тук документацията е грешна; синтаксисът е променен във версия 4.2: \href{https://stackoverflow.com/questions/43963179/c-sharp-antlr4-right-associative-warning}{тема в StackOverflow}}
За постигане на ``не-асоциативни'' операции, трябва да се напише специално преминаване, което да засича грешната употреба и да отпечатва грешка.

\subsection{Лява Рекурсивност}

(Предстои да бъде дописано.)

Лявата рекурсивност е позволена, стига да е директна (един нетерминал може да се презапише в последователност, започваща пак с него).
Индиректната лява рекурсивност е забранена и води до отпечатване на грешка ``The following sets of rules are mutually left-recursive ...''.
Това ограничава гъвкавостта при писането на граматика и затова по-сложните проблеми трябва да се решават в специализиранo преминаване през АСД след неговото построение (конкретно -- реализацията на ``не-асоциативни'' оператори).

\subsection{Първоначална Граматика}

Шаблонният код от тази част включва следната първоначална граматика:

\begin{verbatim}
parser grammar CoolParser;
options { tokenVocab=CoolLexer; }
program: (class ';')+ ;
class  : CLASS TYPEID '{' '}' ;
\end{verbatim}

\noindent Тя предполага, че лексикалният анализатор е дефиниран в CoolLexer.g4 и че съдържа дефиниции на видовете жетони CLASS, TYPEID, '{', и '}'.
Няма да е нужно да променяте нетерминалът program, но ще трябва да допълните дефиницията на class, както и да добавите нови нетерминали, които рекурсивно да изграждат цялата синтактична структура на програмния език COOL.
Задачата не е лека, но крайният резултат е учудващо кратък и изразителен.

\subsection{Visitor Pattern}

(Предстои да бъде дописано.)

В режим \texttt{-visitor} (този, който се използва от псевдонима antlr4 в развойната среда, която сме ви предоставили) за всеки нетерминал, например name, се генерира функция visitName.
Ако граматиката ви се казва Foo.g4, тогава се генерира и клас FooBaseVisitor, който съдържа тези visitor методи.
Основната част от работата ви, освен дефиницията на правилна граматика, ще бъде да реализирате клас наследяващ този BaseVisitor.
Шаблонният код съдържа първоначална дефиниция на този клас -- TreePrinter.

Може да променяте TreePriner, както си пожелаете, стига промяната да доведе до работещ синтактичен анализатор.
Основният модел на изпълнение е следният.
Функцията print е входната точка към функционалността на класа.
На свой ред, тя извиква visitProgram, с което се започва посещаването на всички елементи на АСД.
Това посещаване се изпълнява автоматично, стига да не презапишете някоя от visit функциите.
Когато го направите (ще е необходимо), е желателно да извиката отново друга visit функция, за да продължи посещаването надолу по дървото.
Например, ако сте презаписали visitProgram до следното:

\begin{verbatim}
    any visitProgram(CoolParser::ProgramContext *ctx) override {
        cout << "_program" << endl;
        visitChildren(ctx);
        return any{};
    }
\end{verbatim}

\noindent в случай че visitChildren липсваше, нямаше да се извика транзитивно visitClass.
Така преминаването през програмата няма да е пълно.
В някои случаи това е желателно, но при TreePrinter, който цели да отпечата цялата програма, това е бъг.

\subsection{std::any}

Генерираният ``посетител'' на АСД използва std::any като тип на върнатата стойност от всеки visit метод.
Това е механизъм, който позволява връщането на стойност от който и да е тип, стига тази стойност да бъде опакована в std::any, например така:

\begin{verbatim}
  return std::any{std::string("hello")};
\end{verbatim}

\noindent Обърнете внимание на допълнителното обвиване на ``hello'' в std::string.
Няма да изпадаме в детайли, но за други стойности това не е нужно.
Важното е да знаете, че в случай, че искате да използвате символен низ като стойност, сме ви спестили с този пример много главоболия :-)
За да използвате стойността в част от кода, която директно извиква някоя visit функция, трябва да ползвате std::any\_cast, за да я разопаковате.

\begin{verbatim}
  auto message = std::any_cast<std::string>(visitClass(ctx->class(0)));
\end{verbatim}

За да обобщим, следното е друг пример:

\begin{verbatim}
std::any visitClass(CoolParser::ClassContext *ctx) override{
  return std::any{13};
}
  ...
  auto unfortunate = std::any_cast<int>(visitClass(ctx->class(0)));
\end{verbatim}

В случай, че се опитате да разопаковате стойност в тип, който не ѝ съответства, any\_cast ще хвърли изключение от тип std::bad\_any\_cast.
Така че може да получите следната грешка по време на изпълнение:

\subsection{CoolLexer.h}

Служебният лексикален анализатор и двете му функции.

(Следва да се напише.)

\begin{verbatim}
terminate called after throwing an instance of 'std::bad_any_cast'
\end{verbatim}

\section{Предаване на Решение}

(Следва да се напише.)

За да предадете решение, изпълнете ``tools/grade-lexer.sh'' в контейнера.
Този скрипт ще отпечата код за предаване, например ``1:c4ca4238a0b923820dcc509a6f75849b''.
Копирайте този код в специалния \href{https://learn.fmi.uni-sofia.bg/mod/quiz/view.php?id=358624}{формуляр за предаване в Мудъл}.
Освен това, трябва да качите и променения от вас код (само ``CoolLexer.g4'' и ``LexerDriver.cpp'') в специалната \href{https://learn.fmi.uni-sofia.bg/mod/publication/view.php?id=359465}{папка за предаване в Мудъл}.

(Следва да се напише.)

\end{document}
